'use strict';

const url = require('url');
const path = require('path');
const fs = require('fs-extra');
const _ = require('lodash');
const imagemin = require('imagemin');
const imageminWebp = require('imagemin-webp');
const OffscreenImages = require('lighthouse/lighthouse-core/audits/byte-efficiency/offscreen-images');
const Optimizer = require('./Optimizer');

const { URL } = url;

const toUrlFromPath = (destDir, destPath) => `/${path.relative(destDir, destPath)}`;

const isVisible = (image, viewportDimensions) => {
  const visiblePixels = OffscreenImages.computeVisiblePixels(image.clientRect, viewportDimensions);
  return visiblePixels > 0;
};

/**
 * Optimize Strategy
 * 1. Ignore all images from a third server
 * 2. Make use of lazyload
 * 3. Transform to webp
 * 4. Resize image based on max size
 * 5. Reduce image
 */
class ImageOptimizer extends Optimizer {
  static get meta() {
    return {
      requiredArtifacts: ['ImageElements', 'ViewportDimensions', 'URL'],
    };
  }

  /**
   * Extract useful data from raw artifacts
   * @param artifacts
   * @returns {Array}
   */
  static extractImages(artifacts) {
    const viewportDimensions = artifacts.ViewportDimensions;
    const imageElementsGroupBySrc = _.groupBy(artifacts.ImageElements, 'src');
    const images = [];
    _.each(imageElementsGroupBySrc, imageElements => {
      // Image elements might use same url, Sadly we're not able to identify them from `artifacts.json` generated by lighthouse.
      // We have to be conservative as soon as possible. Like we have to ignore imageElements used as CSS background or has `object-fit` property.
      const combinedImage = {
        ...imageElements[0],
        isVisible: imageElements.some(image => isVisible(image, viewportDimensions)),
        displayedMaxWidth: _.maxBy(_.map(imageElements, 'displayedWidth')),
        displayedMaxHeight: _.maxBy(_.map(imageElements, 'displayedHeight')),
        hasBeenUsedInCss: imageElements.some(image => image.isCss),
        usesObjectFit: imageElements.some(image => image.usesObjectFit),
      };
      if (combinedImage.src) {
        images.push(combinedImage);
      }
    });
    return images;
  }

  static computeResize(image) {
    const { displayedMaxWidth, displayedMaxHeight, naturalWidth, naturalHeight } = image;
    if (!(displayedMaxWidth < naturalWidth && displayedMaxHeight < naturalHeight)) {
      return undefined;
    }
    const ratio = naturalWidth / naturalHeight;
    if (displayedMaxWidth >= displayedMaxHeight * ratio) {
      return {
        width: displayedMaxWidth,
        height: displayedMaxWidth / ratio,
      };
    }
    return {
      width: displayedMaxHeight * ratio,
      height: displayedMaxHeight,
    };
  }

  /**
   * Optimize image based on the collected data.
   * No matter an image is optimized or not, relative url in dest dir will be attached.
   * @param image
   * @param context
   * @returns {Promise<{relativeUrl: string}>}
   */
  static async optimizeImage(image, context) {
    const imageUrl = new URL(image.src);
    const { pathname } = imageUrl;
    const isUrlFromCurrentSite = imageUrl.origin === context.siteURL.origin;
    if (!isUrlFromCurrentSite) {
      return {
        ...image,
        relativeUrl: image.src,
      };
    }
    const srcPath = path.resolve(context.srcDir, `.${pathname}`);
    const destPath = path.resolve(context.destDir, `.${pathname}`);
    if (image.hasBeenUsedInCss || image.usesObjectFit) {
      const data = await fs.readFile(srcPath);
      await fs.outputFile(destPath, data);
      return {
        ...image,
        relativeUrl: pathname,
      };
    }
    const resize = this.computeResize(image);
    const files = await imagemin([srcPath], {
      destination: path.dirname(destPath),
      plugins: [imageminWebp({ quality: 85, resize })],
    });
    const newDestPath = toUrlFromPath(context.destDir, files[0].destinationPath);
    return {
      ...image,
      relativeUrl: newDestPath,
    };
  }

  static applyOptimizedImage($element, image) {
    $element.attr('src', image.relativeUrl);
    if (!image.isVisible) {
      $element.removeAttr('src');
      $element.attr('data-src', image.relativeUrl);
    }
  }

  // The gzip size of this script is 2.2K. Now we could simply say it always deserve.
  static ensureLazyLoadImageScript($) {
    const lazyLoadUrl = 'https://cdn.jsdelivr.net/npm/vanilla-lazyload@12.0.0/dist/lazyload.min.js';
    if ($(`script[src="${lazyLoadUrl}"]`).length === 0) {
      $('body').append(`
          <script src="${lazyLoadUrl}"></script>
          <script>
            var lazyLoadInstance = new LazyLoad({
            });
           </script>
        `);
    }
  }

  static async optimize($, artifacts, context) {
    const images = await Promise.all(
      this.extractImages(artifacts).map(image => this.optimizeImage(image, context))
    );
    const imageMapByUrl = new Map();
    images.forEach(image => imageMapByUrl.set(image.src, image));
    const pageUrl = artifacts.URL.finalUrl;
    $('img[src]').each((i, element) => {
      const imageUrl = decodeURIComponent(url.resolve(pageUrl, $(element).attr('src')));
      const image = imageMapByUrl.get(imageUrl);
      if (image) {
        this.applyOptimizedImage($(element), image);
      } else {
        console.warn(
          `Lack information of image which url is ${imageUrl}. There must be something wrong.`
        );
      }
    });
    if (images.some(image => !image.isVisible)) {
      this.ensureLazyLoadImageScript($);
    }
  }
}

module.exports = ImageOptimizer;
